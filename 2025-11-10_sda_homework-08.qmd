---
title: "Homework-08: Geostatistics Homework (Prediction)"
author: "E. Duke Chase"
date: today
---
```{r}
#| label: setup
#| include: false

library(here)
source(here::here("R", "setup.R"))
```

The `cow.rda` file contains a data frame with 200 spatial observations observed throughout the state of Colorado.  The data frame includes `easting` and `northing` coordinates (UTM, scaled by 1000 meters) and Tungsten measurements (`W`) at each site (mg/kg). Read in the data as a data frame from the file.  

# Preliminaries

Load the **gstat** and **geoR** packages. Load the `cow.rda` file.

# Problem 0

Create `cow_sf`, an `sf` version of `cow` that uses `easting` and `northing` for `coords`. 

Create `geocow`, a `geodata` object from the **geoR** package.

Also run the following code.

```{r}
set.seed(1)
poly_sf <- sf::st_polygon(x = list(cbind(
  c(152, 152, 753, 753, 152),
  c(4100, 4544, 4544, 4100, 4100))))

grid_sf <- sf::st_sample(poly_sf, size = 100,
                         type = "regular")
```

**Solution**

```{r}
#| label: p_0-setup
#| code-fold: show

# Load data
load(here("data", "cow.rda"))

# Create `sf` and `geodata` versions of the data
cow_sf <- sf::st_as_sf(cow, coords = c("easting", "northing"))
geocow <- as.geodata(cbind(cow$easting, cow$northing, cow$W))
```


# Problem 1 (Using geoR)

Use REML estimation with a constant mean function to fit the following covariance models to the data:

a. An isotropic spherical model.
b. A geometric anisotropic spherical model.
c. An isotropic exponential model.
d. A geometric anisotropic exponential model.

Make a table that provides the following information about each model: model, partial sill ($c$), range parameter ($a$ or $a_{min}$), nugget ($c_0$), direction of the major axis in degrees, (if appropriate), anisotropy ratio $a_{max}/a_{min}$, AIC of the fit.

Note: starting values make a HUGE difference for the anisotropic models, so you probably want to experiment a bit.

Which model is the best choice?

**Solution**

```{r}
#| label: p_1
#| warning: false
#| error: false

# plot(variog(geocow))
# plot(variog4(geocow))

# Preliminary guesses (after a few rounds of trying different values)
psill_est <- 1.2
range_est <- 30
nugget_est <- 0

# Define models
## Isotropic spherical
lfit_isosph <- cache_computation({
  likfit(
    geocow,
    ini.cov.pars = c(psill_est, range_est),
    nugget = nugget_est,
    cov.model = "spherical",
    lik.method = "REML"
  )
}, cache_filename = "lfit_isosph.rds", parallel = FALSE)


## Geometric anisotropic spherical
lfit_anisph <- cache_computation({
  likfit(geocow,
     ini.cov.pars = c(psill_est, range_est),
     nugget = nugget_est,
     cov.model = "spherical",
     lik.method = "REML",
     psiA = 0,
     fix.psiA = FALSE,
     psiR = 1,
     fix.psiR = FALSE)
}, cache_filename = "lfit_anisph.rds", parallel = FALSE)


## Isotropic exponential
lfit_isoexp <- cache_computation({
  likfit(geocow,
         ini.cov.pars = c(psill_est, range_est),
         nugget = nugget_est,
         cov.model = "exponential",
         lik.method = "REML")
}, cache_filename = "lfit_isoexp.rds", parallel = FALSE)


## Geometric anisotropic exponential
lfit_aniexp <- cache_computation({
  likfit(geocow,
                         ini.cov.pars = c(psill_est, range_est),
                         nugget = nugget_est,
                         cov.model = "exponential",
                         lik.method = "REML",
                         psiA = 0,
                         fix.psiA = FALSE,
                         psiR = 1,
                         fix.psiR = FALSE)
}, cache_filename = "lfit_aniexp.rds", parallel = FALSE)


# Extract values for table
## Partial sills
psill_isosph <- lfit_isosph$cov.pars[1]
psill_anisph <- lfit_anisph$cov.pars[1]
psill_isoexp <- lfit_isoexp$cov.pars[1]
psill_aniexp <- lfit_aniexp$cov.pars[1]

## Ranges
range_isosph <- lfit_isosph$cov.pars[2]
range_anisph <- lfit_anisph$cov.pars[2]
range_isoexp <- lfit_isoexp$cov.pars[2]
range_aniexp <- lfit_aniexp$cov.pars[2]

## Nuggets
nugget_isosph <- lfit_isosph$nugget
nugget_anisph <- lfit_anisph$nugget
nugget_isoexp <- lfit_isoexp$nugget
nugget_aniexp <- lfit_aniexp$nugget


## Major axis (deg)
axis_anisph <- lfit_anisph$aniso.pars[1] * 180 / pi
axis_aniexp <- lfit_aniexp$aniso.pars[1] * 180 / pi


## Anisotropy ratio
anirat_anisph <- 1 / lfit_anisph$aniso.pars[2]
anirat_aniexp <- 1 / lfit_aniexp$aniso.pars[2]


## AIC
aic_isosph <- lfit_isosph$AIC
aic_anisph <- lfit_anisph$AIC
aic_isoexp <- lfit_isoexp$AIC
aic_aniexp <- lfit_aniexp$AIC

# Build the table
p1_table <- tibble(
  Model = c("Isotropic Spherical", "Anisotropic Spherical",
            "Isotropic Exponential", "Anisotropic Exponential"),
  "Partial Sill" = c(psill_isosph, psill_anisph, psill_isoexp, psill_aniexp),
  Range = c(range_isosph, range_anisph, range_isoexp, range_aniexp),
  Nugget = c(nugget_isosph, nugget_anisph, nugget_isoexp, nugget_aniexp),
  "Major Axis (deg)" = c(NA, axis_anisph, NA, axis_aniexp),
  "Anisotropy Ratio" = c(NA, anirat_anisph, NA, anirat_aniexp),
  AIC = c(aic_isosph, aic_anisph, aic_isoexp, aic_aniexp)
)

knitr::kable(p1_table, digits = 3) |> 
  kable_styling(bootstrap_options = c("striped", "condensed"))
```

::: {.answer-box}
  Based on AIC, the geometric anisotropic exponential model is the best by a fair margin.
:::



# Problem 2

Create two `gstat` objects with a constant mean and the directional semivariogram model that matches the REML fit provided below. For the first, assume the nugget is microscale error (standard kriging) while the second is measurement error (filtered kriging).

Reminder: **gstat** and **geoR** parameterize the angle and ratio of the $a_{minor}$ and $a_{major}$ differently, so carefully read the documentation. 

```
Summary of the parameter estimation
-----------------------------------
Estimation method: restricted maximum likelihood 

Parameters of the mean component (trend):
  beta 
0.9343 

Parameters of the spatial component:
   correlation function: exponential
      (estimated) variance parameter sigmasq (partial sill) =  1.158
      (estimated) cor. fct. parameter phi (range parameter)  =  3.276
   anisotropy parameters:
      (fixed) anisotropy angle = 0.7854  ( 45.0001052295748 degrees )
      (fixed) anisotropy ratio = 2

Parameter of the error component:
      (estimated) nugget =  0.102

Transformation parameter:
      (fixed) Box-Cox parameter = 1 (no transformation)

Practical Range with cor=0.05 for asymptotic range: 9.812505

Maximised Likelihood:
   log.L n.params      AIC      BIC 
"-296.1"      "4"  "600.1"  "613.3" 

non spatial model:
   log.L n.params      AIC      BIC 
"-297.6"      "2"  "599.1"  "605.7" 

Call:
likfit(geodata = geocow, ini.cov.pars = c(0.5, 10), fix.nugget = FALSE, 
    nugget = 0.1, fix.psiA = TRUE, psiA = pi/4, fix.psiR = TRUE, 
    psiR = 2, cov.model = "exponential", lik.method = "REML", 
    messages = FALSE)
```

**Solution**

```{r}
#| label: p_2
#| code-fold: show

# Params from summary
psill_2 <- 1.158
a_min_2 <- 3.276
psiR_2 <- 2
a_max_2 <- a_min_2 * psiR_2
nugget_2 <- 0.102
angle_gstat_2 <- 45
ratio_gstat_2 <- 1 / psiR_2

# Standard Kriging Model
vgm_standard_2 <- vgm(
  psill = psill_2,
  model = "Exp",
  range = a_max_2,
  nugget = nugget_2,
  anis = c(angle_gstat_2, ratio_gstat_2)
)

gstat_stdkrig_2 <- gstat(
  id = "W",
  formula = W ~ 1,
  data = cow_sf,
  model = vgm_standard_2
)

# Filtered Kriging Model
vgm_filtered_2 <- vgm(
  psill = psill_2,
  model = "Exp",
  range = a_max_2,
  Err = nugget_2,
  anis = c(angle_gstat_2, ratio_gstat_2)
)

gstat_filtkrig_2 <- gstat(
  id = "W",
  formula = W ~ 1,
  data = cow_sf,
  model = vgm_filtered_2
)
```



# Problem 3

Perform standard kriging at the locations contained in `grid_sf` using the `gstat` object created in the previous problem.

Use the `summary` function to summarize your results.

**Solution**

```{r}
#| label: p_3

ok_3 <- predict(gstat_stdkrig_2, newdata = grid_sf)
summary(ok_3)
```


# Problem 4

Perform filtered kriging at the locations contained in `grid_sf` using the `gstat` object created in Problem 2.

Use the `summary` function to summarize your results.

**Solution**

```{r}
#| label: p_4

fok_4 <- predict(gstat_filtkrig_2, newdata = grid_sf)
summary(fok_4)
```


# Problem 5

Are the predictions for standard and filtered kriging identical for the predictions above? Why?

**Solution**

```{r}
#| label: p_5

all.equal(ok_3$W.pred, fok_4$W.pred)
```


::: {.answer-box}
  The predicted tungsten values are the same for both standard and filtered kriging. This is because filtered kriging assumes measurement error, and when interpolating at unobserved points there is no measurement error to account for, so it will give the same results as standard kriging at those unobserved locations.
:::


# Problem 6

Create side-by-side plots of the kriging variances from Problems 3 and 4 with a common color scale. Which variances are higher?

**Solution**

```{r}
#| label: p_6

# ggplot(ok_3) + geom_sf(aes(col = W.var))
# ggplot(fok_4) + geom_sf(aes(col = W.var))

# Create data frame to create plots side by side
psf <- rbind(cbind(ok_3, type = "standard"),
             cbind(fok_4, type = "filtered"))

ggplot(psf) + geom_sf(aes(col = W.var)) + facet_wrap(~ type) + ggtitle("kriging variance")
```

::: {.answer-box}
  As expected, the variances for standard kriging are higher than for filtered kriging, since they assume the nugget is microscale error and reflect the uncertainty in predicting the total signal + microscale error, while filtered kriging is lower because it is predicting signal only, and treating the nugget as measurement error.
:::



# Problem 7

Perform standard kriging at the locations contained in `cow_sf` using the `gstat` object created in Problem 2.

Use the `summary` function to summarize your results.

**Solution**

```{r}
#| label: p_7

ok_7 <- predict(gstat_stdkrig_2, newdata = cow_sf)
summary(ok_7)
```


# Problem 8

Perform filtered kriging at the locations contained in `cow_sf` using the `gstat` object created in Problem 2.

Use the `summary` function to summarize your results.

**Solution**

```{r}
#| label: p_8

fok_8 <- predict(gstat_filtkrig_2, newdata = cow_sf)
summary(fok_8)
```


# Problem 9

Are the standard and unfiltered kriging predictions the same at the observed data locations? Why?

**Solution**

::: {.answer-box}
  No, which is to be expected, because standard kriging is an exact interpolator, and will predict exactly the observed values if you try to predict at observed locations. With filtered kriging, it is not an exact interpolator and it will use smoothing to try and account for measurement error at those locations to give error-free predictions.
:::


# Problem 10

What do you notice about the kriging variances for the filtered and unfiltered kriging predictions at observed data locations?

**Solution**

::: {.answer-box}
  The variance for standard kriging is essentially zero, with what are likely just some floating point artifacts making the values not be exactly zero. For the filtered kriging the variances at the observed points are all in the range of [0.090, 0.094], which is just a bit less than the nugget value from REML fit from problem 2 that we assigned as the measurement error, which makes sense given that filtered kriging is intended to account for measurement error.
:::
